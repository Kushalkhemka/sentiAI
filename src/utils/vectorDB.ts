
import { ChromaClient } from 'chromadb';
import { ChatHistory, Message, Sentiment, VectorDBEntry, SimilarMessage } from '@/types/chat';

// Initialize ChromaDB client (this uses an in-memory database by default)
const chroma = new ChromaClient();

// Collection name for our embeddings
const COLLECTION_NAME = "chat-embeddings";
let collection: any = null;

// Initialize the collection
export const initVectorDB = async () => {
  try {
    // Try to get an existing collection, or create a new one if it doesn't exist
    try {
      collection = await chroma.getCollection({ name: COLLECTION_NAME });
      console.log("Retrieved existing ChromaDB collection");
    } catch (error) {
      // Collection doesn't exist yet, create it
      collection = await chroma.createCollection({ 
        name: COLLECTION_NAME,
        embeddingFunction: {
          generate: generateEmbeddings,
        }
      });
      console.log("Created new ChromaDB collection");
    }
    return true;
  } catch (error) {
    console.error("Failed to initialize ChromaDB:", error);
    return false;
  }
};

// Generate embeddings using OpenAI API
async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  try {
    const OPENAI_API_URL = "https://api.openai.com/v1";
    const OPENAI_API_KEY = "sk-your-openai-api-key"; // Replace with the actual API key
    
    const response = await fetch(`${OPENAI_API_URL}/embeddings`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        input: texts,
        model: "text-embedding-ada-002"
      })
    });
    
    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`);
    }
    
    const data = await response.json();
    return data.data.map((item: any) => item.embedding);
  } catch (error) {
    console.error("Error generating embeddings:", error);
    // Return empty embeddings as fallback
    return texts.map(() => new Array(1536).fill(0));
  }
}

// Store a message in the vector database
export const storeMessageInVectorDB = async (message: Message, conversationId: string): Promise<boolean> => {
  if (!collection) {
    const initialized = await initVectorDB();
    if (!initialized) return false;
  }
  
  try {
    // Only store user messages
    if (message.sender !== "user") return true;
    
    await collection.add({
      ids: [message.id],
      documents: [message.content],
      metadatas: [{
        messageId: message.id,
        conversationId: conversationId,
        timestamp: message.timestamp,
        sentiment: message.sentiment || "neutral"
      }],
    });
    
    return true;
  } catch (error) {
    console.error("Error storing message in vector DB:", error);
    return false;
  }
};

// Store multiple messages at once
export const storeConversationHistoryInVectorDB = async (history: ChatHistory): Promise<boolean> => {
  if (!collection) {
    const initialized = await initVectorDB();
    if (!initialized) return false;
  }
  
  try {
    // Filter for only user messages
    const userMessages = history.messages.filter(m => m.sender === "user");
    
    if (userMessages.length === 0) return true;
    
    const entries: VectorDBEntry[] = userMessages.map(message => ({
      id: message.id,
      content: message.content,
      embedding: [], // Will be generated by ChromaDB's embedding function
      metadata: {
        messageId: message.id,
        conversationId: history.id,
        timestamp: message.timestamp,
        sentiment: message.sentiment as Sentiment || "neutral"
      }
    }));
    
    await collection.add({
      ids: entries.map(entry => entry.id),
      documents: entries.map(entry => entry.content),
      metadatas: entries.map(entry => ({
        messageId: entry.metadata.messageId,
        conversationId: entry.metadata.conversationId,
        timestamp: new Date(entry.metadata.timestamp).toISOString(),
        sentiment: entry.metadata.sentiment
      })),
    });
    
    return true;
  } catch (error) {
    console.error("Error storing conversation history in vector DB:", error);
    return false;
  }
};

// Find similar messages to the given query
export const findSimilarMessages = async (query: string, limit: number = 5): Promise<SimilarMessage[]> => {
  if (!collection) {
    const initialized = await initVectorDB();
    if (!initialized) return [];
  }
  
  try {
    const results = await collection.query({
      queryTexts: [query],
      nResults: limit,
    });
    
    const documents = results.documents[0];
    const metadatas = results.metadatas[0];
    const distances = results.distances[0];
    
    if (!documents || !metadatas || !distances) {
      return [];
    }
    
    return documents.map((content: string, index: number) => ({
      messageId: metadatas[index].messageId,
      content,
      similarity: 1 - distances[index], // Convert distance to similarity score (0-1)
      conversationId: metadatas[index].conversationId,
    }));
  } catch (error) {
    console.error("Error finding similar messages:", error);
    return [];
  }
};
